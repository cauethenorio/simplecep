import os
import logging
import socket
import sys
import time
from timeit import default_timer as timer
from unittest import mock
from urllib.request import urlopen
from urllib.error import URLError, HTTPError

from black import format_str, FileMode

from .providers_tests_data import providers_tests_data


captured_responses = []


def get_logger():
    """
    logs whats being fetched
    """
    logger = logging.getLogger(__name__)
    logger.setLevel(logging.INFO)
    f_format = logging.Formatter("%(asctime)s - %(levelname)s - %(message)s")
    c_handler = logging.StreamHandler()
    c_handler.setFormatter(f_format)
    logger.addHandler(c_handler)
    return logger


logger = get_logger()


class UnexpectedNetworkError(Exception):
    """
    On real network errors like timeouts or DNS problems we need to raise
    a different errors because URLError is captured inside the providers code.
    """


def patched_urlopen(req, timeout):
    """
    Captures request and response data and store
    """
    captured = {
        "request": {
            "full_url": req.full_url,
            "method": req.method,
            "headers": req.headers,
            "data": req.data,
        }
    }
    start_timer = timer()

    try:
        res = urlopen(req, timeout=timeout)
    except HTTPError as error:
        captured["response"] = {
            "type": "error",
            "status": error.status,
            "data": error.read(),
        }
    except (URLError, socket.timeout):
        elapsed_time = timer() - start_timer
        logger.exception(
            "Couldn't capture response (waited {elapsed_time:2.2f}s) from {method:<4} to {full_url}".format(
                elapsed_time=elapsed_time, **captured["request"]
            )
        )
        sys.exit(1)
    else:
        captured["response"] = {"type": "success", "data": res.read()}

    elapsed_time = timer() - start_timer
    logger.info(
        "Captured {response_type:<7} response in {elapsed_time:2.2f}s from "
        "{method:<4} to {full_url}".format(
            elapsed_time=elapsed_time,
            response_type=captured["response"]["type"],
            **captured["request"],
        )
    )

    captured_responses.append(captured)
    return urlopen(req, timeout=timeout)


def save_to_file(data):
    filename = "captured_responses.py"
    dir_path = os.path.dirname(os.path.realpath(__file__))
    path = os.path.join(dir_path, filename)

    formatted_str = format_str(repr(data), mode=FileMode())
    now_ts = time.strftime("%a, %d %b %Y %H:%M:%S +0000", time.gmtime())

    content = f"""\
# This file was generated by the "{os.path.basename(__file__)}" script.
# On {now_ts}.
#
# To update it run:
# python -m tests.providers.capture_real_responses

captured_responses = {formatted_str}
"""
    with open(path, "w") as writer:
        writer.write(content)


def main():
    from simplecep.providers import ALL_PROVIDERS

    with mock.patch("simplecep.providers.commons.urlopen", wraps=patched_urlopen):
        for test_data in providers_tests_data:
            for cep_provider in ALL_PROVIDERS:
                cep_provider(test_data["input"], timeout=5)
    save_to_file(captured_responses)


if __name__ == "__main__":
    main()
